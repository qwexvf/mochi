import * as $dict from "../../../gleam_stdlib/gleam/dict.mjs";
import * as $list from "../../../gleam_stdlib/gleam/list.mjs";
import * as $option from "../../../gleam_stdlib/gleam/option.mjs";
import { None, Some } from "../../../gleam_stdlib/gleam/option.mjs";
import * as $string from "../../../gleam_stdlib/gleam/string.mjs";
import {
  Ok,
  Error,
  toList,
  Empty as $Empty,
  prepend as listPrepend,
  CustomType as $CustomType,
} from "../../gleam.mjs";
import * as $schema from "../../mochi/schema.mjs";

export class Config extends $CustomType {
  constructor(include_descriptions, include_builtin_scalars, indent, header) {
    super();
    this.include_descriptions = include_descriptions;
    this.include_builtin_scalars = include_builtin_scalars;
    this.indent = indent;
    this.header = header;
  }
}
export const Config$Config = (include_descriptions, include_builtin_scalars, indent, header) =>
  new Config(include_descriptions, include_builtin_scalars, indent, header);
export const Config$isConfig = (value) => value instanceof Config;
export const Config$Config$include_descriptions = (value) =>
  value.include_descriptions;
export const Config$Config$0 = (value) => value.include_descriptions;
export const Config$Config$include_builtin_scalars = (value) =>
  value.include_builtin_scalars;
export const Config$Config$1 = (value) => value.include_builtin_scalars;
export const Config$Config$indent = (value) => value.indent;
export const Config$Config$2 = (value) => value.indent;
export const Config$Config$header = (value) => value.header;
export const Config$Config$3 = (value) => value.header;

/**
 * Default configuration
 */
export function default_config() {
  return new Config(
    true,
    false,
    "  ",
    new Some("# Generated by mochi\n# https://github.com/qwexvf/mochi"),
  );
}

function generate_schema_definition(schema) {
  let fields = toList([]);
  let _block;
  let $ = schema.query;
  if ($ instanceof Some) {
    let q = $[0];
    _block = listPrepend("  query: " + q.name, fields);
  } else {
    _block = fields;
  }
  let fields$1 = _block;
  let _block$1;
  let $1 = schema.mutation;
  if ($1 instanceof Some) {
    let m = $1[0];
    _block$1 = listPrepend("  mutation: " + m.name, fields$1);
  } else {
    _block$1 = fields$1;
  }
  let fields$2 = _block$1;
  let _block$2;
  let $2 = schema.subscription;
  if ($2 instanceof Some) {
    let s = $2[0];
    _block$2 = listPrepend("  subscription: " + s.name, fields$2);
  } else {
    _block$2 = fields$2;
  }
  let fields$3 = _block$2;
  return ("schema {\n" + $string.join($list.reverse(fields$3), "\n")) + "\n}";
}

function escape_string(s) {
  let _pipe = s;
  let _pipe$1 = $string.replace(_pipe, "\\", "\\\\");
  let _pipe$2 = $string.replace(_pipe$1, "\"", "\\\"");
  return $string.replace(_pipe$2, "\n", "\\n");
}

function generate_description(description, indent, config) {
  let $ = config.include_descriptions;
  if ($ && description instanceof Some) {
    let desc = description[0];
    let $1 = $string.contains(desc, "\n");
    if ($1) {
      return (((((indent + "\"\"\"\n") + indent) + desc) + "\n") + indent) + "\"\"\"\n";
    } else {
      return ((indent + "\"") + escape_string(desc)) + "\"\n";
    }
  } else {
    return "";
  }
}

function generate_scalar(scalar, config) {
  let desc = generate_description(scalar.description, "", config);
  return (desc + "scalar ") + scalar.name;
}

function generate_enum(enum_type, config) {
  let desc = generate_description(enum_type.description, "", config);
  let _block;
  let _pipe = $dict.to_list(enum_type.values);
  let _pipe$1 = $list.map(
    _pipe,
    (kv) => {
      let name;
      let value_def;
      name = kv[0];
      value_def = kv[1];
      let value_desc = generate_description(
        value_def.description,
        config.indent,
        config,
      );
      let _block$1;
      let $ = value_def.is_deprecated;
      if ($) {
        let $1 = value_def.deprecation_reason;
        if ($1 instanceof Some) {
          let reason = $1[0];
          _block$1 = (" @deprecated(reason: \"" + escape_string(reason)) + "\")";
        } else {
          _block$1 = " @deprecated";
        }
      } else {
        _block$1 = "";
      }
      let deprecated = _block$1;
      return ((value_desc + config.indent) + name) + deprecated;
    },
  );
  _block = $string.join(_pipe$1, "\n");
  let values = _block;
  return ((((desc + "enum ") + enum_type.name) + " {\n") + values) + "\n}";
}

function generate_union(union, config) {
  let desc = generate_description(union.description, "", config);
  let _block;
  let _pipe = union.types;
  let _pipe$1 = $list.map(_pipe, (t) => { return t.name; });
  _block = $string.join(_pipe$1, " | ");
  let type_names = _block;
  return (((desc + "union ") + union.name) + " = ") + type_names;
}

function field_type_to_sdl(field_type) {
  if (field_type instanceof $schema.NonNull) {
    let inner = field_type.inner;
    return field_type_to_sdl(inner) + "!";
  } else if (field_type instanceof $schema.List) {
    let inner = field_type.inner;
    return ("[" + field_type_to_sdl(inner)) + "]";
  } else {
    let name = field_type.name;
    return name;
  }
}

function generate_input_type(input, config) {
  let desc = generate_description(input.description, "", config);
  let _block;
  let _pipe = $dict.to_list(input.fields);
  let _pipe$1 = $list.map(
    _pipe,
    (kv) => {
      let name;
      let field_def;
      name = kv[0];
      field_def = kv[1];
      let field_desc = generate_description(
        field_def.description,
        config.indent,
        config,
      );
      return (((field_desc + config.indent) + name) + ": ") + field_type_to_sdl(
        field_def.field_type,
      );
    },
  );
  _block = $string.join(_pipe$1, "\n");
  let fields = _block;
  return ((((desc + "input ") + input.name) + " {\n") + fields) + "\n}";
}

function generate_arguments(arguments$) {
  let _pipe = $dict.to_list(arguments$);
  let _pipe$1 = $list.map(
    _pipe,
    (kv) => {
      let name;
      let arg_def;
      name = kv[0];
      arg_def = kv[1];
      let _block;
      let $ = arg_def.default_value;
      if ($ instanceof Some) {
        _block = " = <default>";
      } else {
        _block = "";
      }
      let default$ = _block;
      return ((name + ": ") + field_type_to_sdl(arg_def.arg_type)) + default$;
    },
  );
  return $string.join(_pipe$1, ", ");
}

function generate_field(field, config) {
  let desc = generate_description(field.description, config.indent, config);
  let _block;
  let $ = $dict.size(field.arguments) > 0;
  if ($) {
    _block = ("(" + generate_arguments(field.arguments)) + ")";
  } else {
    _block = "";
  }
  let args = _block;
  let _block$1;
  let $1 = field.is_deprecated;
  if ($1) {
    let $2 = field.deprecation_reason;
    if ($2 instanceof Some) {
      let reason = $2[0];
      _block$1 = (" @deprecated(reason: \"" + escape_string(reason)) + "\")";
    } else {
      _block$1 = " @deprecated";
    }
  } else {
    _block$1 = "";
  }
  let deprecated = _block$1;
  return (((((desc + config.indent) + field.name) + args) + ": ") + field_type_to_sdl(
    field.field_type,
  )) + deprecated;
}

function generate_interface(interface$, config) {
  let desc = generate_description(interface$.description, "", config);
  let _block;
  let _pipe = $dict.to_list(interface$.fields);
  let _pipe$1 = $list.map(
    _pipe,
    (kv) => {
      let field_def;
      field_def = kv[1];
      return generate_field(field_def, config);
    },
  );
  _block = $string.join(_pipe$1, "\n");
  let fields = _block;
  return ((((desc + "interface ") + interface$.name) + " {\n") + fields) + "\n}";
}

function generate_object_type(object, config) {
  let desc = generate_description(object.description, "", config);
  let _block;
  let $ = object.interfaces;
  if ($ instanceof $Empty) {
    _block = "";
  } else {
    let interfaces = $;
    let _block$1;
    let _pipe = interfaces;
    let _pipe$1 = $list.map(_pipe, (i) => { return i.name; });
    _block$1 = $string.join(_pipe$1, " & ");
    let names = _block$1;
    _block = " implements " + names;
  }
  let implements$ = _block;
  let _block$1;
  let _pipe = $dict.to_list(object.fields);
  let _pipe$1 = $list.map(
    _pipe,
    (kv) => {
      let field_def;
      field_def = kv[1];
      return generate_field(field_def, config);
    },
  );
  _block$1 = $string.join(_pipe$1, "\n");
  let fields = _block$1;
  return (((((desc + "type ") + object.name) + implements$) + " {\n") + fields) + "\n}";
}

function needs_schema_definition(schema) {
  let $ = schema.query;
  let $1 = schema.mutation;
  let $2 = schema.subscription;
  if ($ instanceof Some) {
    let q = $[0];
    if (q.name !== "Query") {
      return true;
    } else if ($1 instanceof Some) {
      let m = $1[0];
      if (m.name !== "Mutation") {
        return true;
      } else if ($2 instanceof Some) {
        let s = $2[0];
        if (s.name !== "Subscription") {
          return true;
        } else {
          return false;
        }
      } else {
        return false;
      }
    } else if ($2 instanceof Some) {
      let s = $2[0];
      if (s.name !== "Subscription") {
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  } else if ($1 instanceof Some) {
    let m = $1[0];
    if (m.name !== "Mutation") {
      return true;
    } else if ($2 instanceof Some) {
      let s = $2[0];
      if (s.name !== "Subscription") {
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  } else if ($2 instanceof Some) {
    let s = $2[0];
    if (s.name !== "Subscription") {
      return true;
    } else {
      return false;
    }
  } else {
    return false;
  }
}

function get_scalar_types(schema, config) {
  let builtin = toList(["String", "Int", "Float", "Boolean", "ID"]);
  let _pipe = $dict.to_list(schema.types);
  return $list.filter_map(
    _pipe,
    (kv) => {
      let name;
      let type_def;
      name = kv[0];
      type_def = kv[1];
      if (type_def instanceof $schema.ScalarTypeDef) {
        let scalar = type_def.scalar_type;
        let $ = config.include_builtin_scalars || !$list.contains(builtin, name);
        if ($) {
          return new Ok(scalar);
        } else {
          return new Error(undefined);
        }
      } else {
        return new Error(undefined);
      }
    },
  );
}

function get_enum_types(schema) {
  let _pipe = $dict.to_list(schema.types);
  return $list.filter_map(
    _pipe,
    (kv) => {
      let type_def;
      type_def = kv[1];
      if (type_def instanceof $schema.EnumTypeDef) {
        let enum$ = type_def.enum_type;
        return new Ok(enum$);
      } else {
        return new Error(undefined);
      }
    },
  );
}

function get_interface_types(schema) {
  let _pipe = $dict.to_list(schema.types);
  return $list.filter_map(
    _pipe,
    (kv) => {
      let type_def;
      type_def = kv[1];
      if (type_def instanceof $schema.InterfaceTypeDef) {
        let interface$ = type_def.interface_type;
        return new Ok(interface$);
      } else {
        return new Error(undefined);
      }
    },
  );
}

function get_union_types(schema) {
  let _pipe = $dict.to_list(schema.types);
  return $list.filter_map(
    _pipe,
    (kv) => {
      let type_def;
      type_def = kv[1];
      if (type_def instanceof $schema.UnionTypeDef) {
        let union = type_def.union_type;
        return new Ok(union);
      } else {
        return new Error(undefined);
      }
    },
  );
}

function get_input_types(schema) {
  let _pipe = $dict.to_list(schema.types);
  return $list.filter_map(
    _pipe,
    (kv) => {
      let type_def;
      type_def = kv[1];
      if (type_def instanceof $schema.InputObjectTypeDef) {
        let input = type_def.input_object_type;
        return new Ok(input);
      } else {
        return new Error(undefined);
      }
    },
  );
}

function get_object_types(schema) {
  let _pipe = $dict.to_list(schema.types);
  return $list.filter_map(
    _pipe,
    (kv) => {
      let type_def;
      type_def = kv[1];
      if (type_def instanceof $schema.ObjectTypeDef) {
        let obj = type_def.object_type;
        return new Ok(obj);
      } else {
        return new Error(undefined);
      }
    },
  );
}

function get_custom_directives(schema) {
  let builtin = toList(["skip", "include", "deprecated"]);
  let _pipe = $dict.to_list(schema.directives);
  return $list.filter_map(
    _pipe,
    (kv) => {
      let name;
      let directive;
      name = kv[0];
      directive = kv[1];
      let $ = $list.contains(builtin, name);
      if ($) {
        return new Error(undefined);
      } else {
        return new Ok(directive);
      }
    },
  );
}

function generate_directive(directive, config) {
  let desc = generate_description(directive.description, "", config);
  let _block;
  let $ = $dict.size(directive.arguments) > 0;
  if ($) {
    _block = ("(" + generate_arguments(directive.arguments)) + ")";
  } else {
    _block = "";
  }
  let args = _block;
  let _block$1;
  let $1 = directive.is_repeatable;
  if ($1) {
    _block$1 = " repeatable";
  } else {
    _block$1 = "";
  }
  let repeatable = _block$1;
  let _block$2;
  let _pipe = directive.locations;
  let _pipe$1 = $list.map(_pipe, $schema.directive_location_to_string);
  _block$2 = $string.join(_pipe$1, " | ");
  let locations = _block$2;
  return (((((desc + "directive @") + directive.name) + args) + repeatable) + " on ") + locations;
}

/**
 * Generate SDL with custom config
 */
export function generate_with_config(schema, config) {
  let parts = toList([]);
  let _block;
  let $ = config.header;
  if ($ instanceof Some) {
    let header = $[0];
    _block = toList([header, ""]);
  } else {
    _block = parts;
  }
  let parts$1 = _block;
  let scalar_types = get_scalar_types(schema, config);
  let _block$1;
  if (scalar_types instanceof $Empty) {
    _block$1 = parts$1;
  } else {
    let _block$2;
    let _pipe = scalar_types;
    let _pipe$1 = $list.map(
      _pipe,
      (s) => { return generate_scalar(s, config); },
    );
    _block$2 = $string.join(_pipe$1, "\n\n");
    let scalars_sdl = _block$2;
    _block$1 = $list.append(parts$1, toList([scalars_sdl, ""]));
  }
  let parts$2 = _block$1;
  let enum_types = get_enum_types(schema);
  let _block$2;
  if (enum_types instanceof $Empty) {
    _block$2 = parts$2;
  } else {
    let _block$3;
    let _pipe = enum_types;
    let _pipe$1 = $list.map(_pipe, (e) => { return generate_enum(e, config); });
    _block$3 = $string.join(_pipe$1, "\n\n");
    let enums_sdl = _block$3;
    _block$2 = $list.append(parts$2, toList([enums_sdl, ""]));
  }
  let parts$3 = _block$2;
  let interface_types = get_interface_types(schema);
  let _block$3;
  if (interface_types instanceof $Empty) {
    _block$3 = parts$3;
  } else {
    let _block$4;
    let _pipe = interface_types;
    let _pipe$1 = $list.map(
      _pipe,
      (i) => { return generate_interface(i, config); },
    );
    _block$4 = $string.join(_pipe$1, "\n\n");
    let interfaces_sdl = _block$4;
    _block$3 = $list.append(parts$3, toList([interfaces_sdl, ""]));
  }
  let parts$4 = _block$3;
  let union_types = get_union_types(schema);
  let _block$4;
  if (union_types instanceof $Empty) {
    _block$4 = parts$4;
  } else {
    let _block$5;
    let _pipe = union_types;
    let _pipe$1 = $list.map(_pipe, (u) => { return generate_union(u, config); });
    _block$5 = $string.join(_pipe$1, "\n\n");
    let unions_sdl = _block$5;
    _block$4 = $list.append(parts$4, toList([unions_sdl, ""]));
  }
  let parts$5 = _block$4;
  let input_types = get_input_types(schema);
  let _block$5;
  if (input_types instanceof $Empty) {
    _block$5 = parts$5;
  } else {
    let _block$6;
    let _pipe = input_types;
    let _pipe$1 = $list.map(
      _pipe,
      (i) => { return generate_input_type(i, config); },
    );
    _block$6 = $string.join(_pipe$1, "\n\n");
    let inputs_sdl = _block$6;
    _block$5 = $list.append(parts$5, toList([inputs_sdl, ""]));
  }
  let parts$6 = _block$5;
  let object_types = get_object_types(schema);
  let _block$6;
  if (object_types instanceof $Empty) {
    _block$6 = parts$6;
  } else {
    let _block$7;
    let _pipe = object_types;
    let _pipe$1 = $list.map(
      _pipe,
      (o) => { return generate_object_type(o, config); },
    );
    _block$7 = $string.join(_pipe$1, "\n\n");
    let objects_sdl = _block$7;
    _block$6 = $list.append(parts$6, toList([objects_sdl, ""]));
  }
  let parts$7 = _block$6;
  let _block$7;
  let $1 = schema.query;
  if ($1 instanceof Some) {
    let query_type = $1[0];
    let query_sdl = generate_object_type(query_type, config);
    _block$7 = $list.append(parts$7, toList([query_sdl, ""]));
  } else {
    _block$7 = parts$7;
  }
  let parts$8 = _block$7;
  let _block$8;
  let $2 = schema.mutation;
  if ($2 instanceof Some) {
    let mutation_type = $2[0];
    let mutation_sdl = generate_object_type(mutation_type, config);
    _block$8 = $list.append(parts$8, toList([mutation_sdl, ""]));
  } else {
    _block$8 = parts$8;
  }
  let parts$9 = _block$8;
  let _block$9;
  let $3 = schema.subscription;
  if ($3 instanceof Some) {
    let subscription_type = $3[0];
    let subscription_sdl = generate_object_type(subscription_type, config);
    _block$9 = $list.append(parts$9, toList([subscription_sdl, ""]));
  } else {
    _block$9 = parts$9;
  }
  let parts$10 = _block$9;
  let _block$10;
  let $4 = needs_schema_definition(schema);
  if ($4) {
    _block$10 = $list.append(
      parts$10,
      toList([generate_schema_definition(schema), ""]),
    );
  } else {
    _block$10 = parts$10;
  }
  let parts$11 = _block$10;
  let custom_directives = get_custom_directives(schema);
  let _block$11;
  if (custom_directives instanceof $Empty) {
    _block$11 = parts$11;
  } else {
    let _block$12;
    let _pipe = custom_directives;
    let _pipe$1 = $list.map(
      _pipe,
      (d) => { return generate_directive(d, config); },
    );
    _block$12 = $string.join(_pipe$1, "\n\n");
    let directives_sdl = _block$12;
    _block$11 = $list.append(parts$11, toList([directives_sdl, ""]));
  }
  let parts$12 = _block$11;
  let _pipe = parts$12;
  let _pipe$1 = $string.join(_pipe, "\n");
  return $string.trim(_pipe$1);
}

/**
 * Generate SDL from a schema with default config
 */
export function generate(schema) {
  return generate_with_config(schema, default_config());
}
