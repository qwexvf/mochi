import * as $dict from "../../../gleam_stdlib/gleam/dict.mjs";
import * as $list from "../../../gleam_stdlib/gleam/list.mjs";
import * as $option from "../../../gleam_stdlib/gleam/option.mjs";
import { None, Some } from "../../../gleam_stdlib/gleam/option.mjs";
import * as $string from "../../../gleam_stdlib/gleam/string.mjs";
import { Ok, Error, toList, Empty as $Empty, CustomType as $CustomType } from "../../gleam.mjs";
import * as $schema from "../../mochi/schema.mjs";

export class Config extends $CustomType {
  constructor(use_exports, use_interfaces, readonly_properties, include_helpers, header) {
    super();
    this.use_exports = use_exports;
    this.use_interfaces = use_interfaces;
    this.readonly_properties = readonly_properties;
    this.include_helpers = include_helpers;
    this.header = header;
  }
}
export const Config$Config = (use_exports, use_interfaces, readonly_properties, include_helpers, header) =>
  new Config(use_exports,
  use_interfaces,
  readonly_properties,
  include_helpers,
  header);
export const Config$isConfig = (value) => value instanceof Config;
export const Config$Config$use_exports = (value) => value.use_exports;
export const Config$Config$0 = (value) => value.use_exports;
export const Config$Config$use_interfaces = (value) => value.use_interfaces;
export const Config$Config$1 = (value) => value.use_interfaces;
export const Config$Config$readonly_properties = (value) =>
  value.readonly_properties;
export const Config$Config$2 = (value) => value.readonly_properties;
export const Config$Config$include_helpers = (value) => value.include_helpers;
export const Config$Config$3 = (value) => value.include_helpers;
export const Config$Config$header = (value) => value.header;
export const Config$Config$4 = (value) => value.header;

/**
 * Default configuration
 */
export function default_config() {
  return new Config(
    true,
    true,
    false,
    true,
    new Some(
      "// Generated by mochi - Do not edit manually\n// https://github.com/qwexvf/mochi",
    ),
  );
}

function generate_helpers() {
  return "/** Represents nullable values */\nexport type Maybe<T> = T | null | undefined;\n\n/** Represents a list that may contain null items */\nexport type MaybeList<T> = Maybe<Maybe<T>[]>;";
}

function generate_scalars(config) {
  let _block;
  let $ = config.use_exports;
  if ($) {
    _block = "export ";
  } else {
    _block = "";
  }
  let export_prefix = _block;
  return export_prefix + "type Scalars = {\n  ID: string;\n  String: string;\n  Int: number;\n  Float: number;\n  Boolean: boolean;\n  /** Custom scalar - extend as needed */\n  DateTime: string;\n  /** Custom scalar - extend as needed */\n  JSON: Record<string, unknown>;\n};";
}

function generate_enum(enum_type, config) {
  let _block;
  let $ = config.use_exports;
  if ($) {
    _block = "export ";
  } else {
    _block = "";
  }
  let export_prefix = _block;
  let _block$1;
  let _pipe = $dict.to_list(enum_type.values);
  let _pipe$1 = $list.map(
    _pipe,
    (kv) => {
      let name;
      let value_def;
      name = kv[0];
      value_def = kv[1];
      let _block$2;
      let $1 = value_def.description;
      if ($1 instanceof Some) {
        let desc = $1[0];
        _block$2 = ("  /** " + desc) + " */\n";
      } else {
        _block$2 = "";
      }
      let comment = _block$2;
      return ((((comment + "  ") + name) + " = \"") + name) + "\",";
    },
  );
  _block$1 = $string.join(_pipe$1, "\n");
  let values = _block$1;
  let _block$2;
  let $1 = enum_type.description;
  if ($1 instanceof Some) {
    let desc = $1[0];
    _block$2 = ("/** " + desc) + " */\n";
  } else {
    _block$2 = "";
  }
  let description = _block$2;
  return (((((description + export_prefix) + "enum ") + enum_type.name) + " {\n") + values) + "\n}";
}

function scalar_to_ts(name) {
  if (name === "ID") {
    return "Scalars[\"ID\"]";
  } else if (name === "String") {
    return "Scalars[\"String\"]";
  } else if (name === "Int") {
    return "Scalars[\"Int\"]";
  } else if (name === "Float") {
    return "Scalars[\"Float\"]";
  } else if (name === "Boolean") {
    return "Scalars[\"Boolean\"]";
  } else if (name === "DateTime") {
    return "Scalars[\"DateTime\"]";
  } else if (name === "JSON") {
    return "Scalars[\"JSON\"]";
  } else {
    return name;
  }
}

function is_nullable(field_type) {
  if (field_type instanceof $schema.NonNull) {
    return false;
  } else {
    return true;
  }
}

function get_object_types(schema) {
  let _pipe = $dict.to_list(schema.types);
  return $list.filter_map(
    _pipe,
    (kv) => {
      let type_def;
      type_def = kv[1];
      if (type_def instanceof $schema.ObjectTypeDef) {
        let obj = type_def.object_type;
        return new Ok(obj);
      } else {
        return new Error(undefined);
      }
    },
  );
}

function get_enum_types(schema) {
  let _pipe = $dict.to_list(schema.types);
  return $list.filter_map(
    _pipe,
    (kv) => {
      let type_def;
      type_def = kv[1];
      if (type_def instanceof $schema.EnumTypeDef) {
        let enum$ = type_def.enum_type;
        return new Ok(enum$);
      } else {
        return new Error(undefined);
      }
    },
  );
}

function get_input_types(schema) {
  let _pipe = $dict.to_list(schema.types);
  return $list.filter_map(
    _pipe,
    (kv) => {
      let type_def;
      type_def = kv[1];
      if (type_def instanceof $schema.InputObjectTypeDef) {
        let input = type_def.input_object_type;
        return new Ok(input);
      } else {
        return new Error(undefined);
      }
    },
  );
}

function capitalize(str) {
  let $ = $string.pop_grapheme(str);
  if ($ instanceof Ok) {
    let first = $[0][0];
    let rest = $[0][1];
    return $string.uppercase(first) + rest;
  } else {
    return str;
  }
}

function field_type_to_ts_non_null(loop$field_type) {
  while (true) {
    let field_type = loop$field_type;
    if (field_type instanceof $schema.NonNull) {
      let inner = field_type.inner;
      loop$field_type = inner;
    } else if (field_type instanceof $schema.List) {
      let inner = field_type.inner;
      return field_type_to_ts(inner) + "[]";
    } else {
      let name = field_type.name;
      return scalar_to_ts(name);
    }
  }
}

function field_type_to_ts(field_type) {
  if (field_type instanceof $schema.NonNull) {
    let inner = field_type.inner;
    return field_type_to_ts_non_null(inner);
  } else if (field_type instanceof $schema.List) {
    let inner = field_type.inner;
    return ("Maybe<" + field_type_to_ts(inner)) + "[]>";
  } else {
    let name = field_type.name;
    return ("Maybe<" + scalar_to_ts(name)) + ">";
  }
}

function generate_object_type(object_type, config) {
  let _block;
  let $ = config.use_exports;
  if ($) {
    _block = "export ";
  } else {
    _block = "";
  }
  let export_prefix = _block;
  let _block$1;
  let $1 = config.use_interfaces;
  if ($1) {
    _block$1 = "interface";
  } else {
    _block$1 = "type";
  }
  let keyword = _block$1;
  let _block$2;
  let $2 = config.readonly_properties;
  if ($2) {
    _block$2 = "readonly ";
  } else {
    _block$2 = "";
  }
  let readonly_prefix = _block$2;
  let _block$3;
  let _pipe = $dict.to_list(object_type.fields);
  let _pipe$1 = $list.map(
    _pipe,
    (kv) => {
      let name;
      let field_def;
      name = kv[0];
      field_def = kv[1];
      let ts_type = field_type_to_ts(field_def.field_type);
      let optional = is_nullable(field_def.field_type);
      let _block$4;
      if (optional) {
        _block$4 = "?";
      } else {
        _block$4 = "";
      }
      let optional_marker = _block$4;
      let _block$5;
      let $3 = field_def.description;
      if ($3 instanceof Some) {
        let desc = $3[0];
        _block$5 = ("  /** " + desc) + " */\n";
      } else {
        _block$5 = "";
      }
      let comment = _block$5;
      return ((((((comment + "  ") + readonly_prefix) + name) + optional_marker) + ": ") + ts_type) + ";";
    },
  );
  _block$3 = $string.join(_pipe$1, "\n");
  let fields = _block$3;
  let _block$4;
  let $3 = object_type.description;
  if ($3 instanceof Some) {
    let desc = $3[0];
    _block$4 = ("/** " + desc) + " */\n";
  } else {
    _block$4 = "";
  }
  let description = _block$4;
  let _block$5;
  let $4 = config.use_interfaces;
  if ($4) {
    _block$5 = " ";
  } else {
    _block$5 = " = ";
  }
  let equals = _block$5;
  return (((((((description + export_prefix) + keyword) + " ") + object_type.name) + equals) + "{\n") + fields) + "\n}";
}

function generate_input_type(input_type, config) {
  let _block;
  let $ = config.use_exports;
  if ($) {
    _block = "export ";
  } else {
    _block = "";
  }
  let export_prefix = _block;
  let _block$1;
  let $1 = config.use_interfaces;
  if ($1) {
    _block$1 = "interface";
  } else {
    _block$1 = "type";
  }
  let keyword = _block$1;
  let _block$2;
  let _pipe = $dict.to_list(input_type.fields);
  let _pipe$1 = $list.map(
    _pipe,
    (kv) => {
      let name;
      let field_def;
      name = kv[0];
      field_def = kv[1];
      let ts_type = field_type_to_ts(field_def.field_type);
      let optional = is_nullable(field_def.field_type);
      let _block$3;
      if (optional) {
        _block$3 = "?";
      } else {
        _block$3 = "";
      }
      let optional_marker = _block$3;
      let _block$4;
      let $2 = field_def.description;
      if ($2 instanceof Some) {
        let desc = $2[0];
        _block$4 = ("  /** " + desc) + " */\n";
      } else {
        _block$4 = "";
      }
      let comment = _block$4;
      return (((((comment + "  ") + name) + optional_marker) + ": ") + ts_type) + ";";
    },
  );
  _block$2 = $string.join(_pipe$1, "\n");
  let fields = _block$2;
  let _block$3;
  let $2 = input_type.description;
  if ($2 instanceof Some) {
    let desc = $2[0];
    _block$3 = ("/** " + desc) + " */\n";
  } else {
    _block$3 = "";
  }
  let description = _block$3;
  let _block$4;
  let $3 = config.use_interfaces;
  if ($3) {
    _block$4 = " ";
  } else {
    _block$4 = " = ";
  }
  let equals = _block$4;
  return (((((((description + export_prefix) + keyword) + " ") + input_type.name) + equals) + "{\n") + fields) + "\n}";
}

function generate_args_type(type_name, field_def, config) {
  let _block;
  let $ = config.use_exports;
  if ($) {
    _block = "export ";
  } else {
    _block = "";
  }
  let export_prefix = _block;
  let _block$1;
  let _pipe = $dict.to_list(field_def.arguments);
  let _pipe$1 = $list.map(
    _pipe,
    (kv) => {
      let name;
      let arg_def;
      name = kv[0];
      arg_def = kv[1];
      let ts_type = field_type_to_ts(arg_def.arg_type);
      let optional = is_nullable(arg_def.arg_type);
      let _block$2;
      if (optional) {
        _block$2 = "?";
      } else {
        _block$2 = "";
      }
      let optional_marker = _block$2;
      let _block$3;
      let $1 = arg_def.description;
      if ($1 instanceof Some) {
        let desc = $1[0];
        _block$3 = ("  /** " + desc) + " */\n";
      } else {
        _block$3 = "";
      }
      let comment = _block$3;
      return (((((comment + "  ") + name) + optional_marker) + ": ") + ts_type) + ";";
    },
  );
  _block$1 = $string.join(_pipe$1, "\n");
  let fields = _block$1;
  return ((((export_prefix + "interface ") + type_name) + " {\n") + fields) + "\n}";
}

function generate_operations(name, object_type, config) {
  let _block;
  let $ = config.use_exports;
  if ($) {
    _block = "export ";
  } else {
    _block = "";
  }
  let export_prefix = _block;
  let _block$1;
  let _pipe = $dict.to_list(object_type.fields);
  let _pipe$1 = $list.filter_map(
    _pipe,
    (kv) => {
      let field_name;
      let field_def;
      field_name = kv[0];
      field_def = kv[1];
      let $1 = $dict.size(field_def.arguments) > 0;
      if ($1) {
        let type_name = (name + capitalize(field_name)) + "Args";
        return new Ok(generate_args_type(type_name, field_def, config));
      } else {
        return new Error(undefined);
      }
    },
  );
  _block$1 = $string.join(_pipe$1, "\n\n");
  let arg_types = _block$1;
  let _block$2;
  let _pipe$2 = $dict.to_list(object_type.fields);
  let _pipe$3 = $list.map(
    _pipe$2,
    (kv) => {
      let field_name;
      let field_def;
      field_name = kv[0];
      field_def = kv[1];
      let return_type = field_type_to_ts(field_def.field_type);
      let _block$3;
      let $1 = field_def.description;
      if ($1 instanceof Some) {
        let desc = $1[0];
        _block$3 = ("  /** " + desc) + " */\n";
      } else {
        _block$3 = "";
      }
      let comment = _block$3;
      let $2 = $dict.size(field_def.arguments) > 0;
      if ($2) {
        let args_type = (name + capitalize(field_name)) + "Args";
        return ((((((comment + "  ") + field_name) + "(args: ") + args_type) + "): ") + return_type) + ";";
      } else {
        return ((((comment + "  ") + field_name) + ": ") + return_type) + ";";
      }
    },
  );
  _block$2 = $string.join(_pipe$3, "\n");
  let fields = _block$2;
  let ops_type = ((((export_prefix + "interface ") + name) + " {\n") + fields) + "\n}";
  if (arg_types === "") {
    return ops_type;
  } else {
    return (arg_types + "\n\n") + ops_type;
  }
}

/**
 * Generate TypeScript code with custom config
 */
export function generate_with_config(schema, config) {
  let parts = toList([]);
  let _block;
  let $ = config.header;
  if ($ instanceof Some) {
    let header = $[0];
    _block = toList([header, ""]);
  } else {
    _block = parts;
  }
  let parts$1 = _block;
  let _block$1;
  let $1 = config.include_helpers;
  if ($1) {
    _block$1 = $list.append(parts$1, toList([generate_helpers(), ""]));
  } else {
    _block$1 = parts$1;
  }
  let parts$2 = _block$1;
  let parts$3 = $list.append(parts$2, toList([generate_scalars(config), ""]));
  let enum_types = get_enum_types(schema);
  let _block$2;
  if (enum_types instanceof $Empty) {
    _block$2 = parts$3;
  } else {
    let _block$3;
    let _pipe = enum_types;
    let _pipe$1 = $list.map(_pipe, (e) => { return generate_enum(e, config); });
    _block$3 = $string.join(_pipe$1, "\n\n");
    let enum_code = _block$3;
    _block$2 = $list.append(parts$3, toList([enum_code, ""]));
  }
  let parts$4 = _block$2;
  let object_types = get_object_types(schema);
  let _block$3;
  if (object_types instanceof $Empty) {
    _block$3 = parts$4;
  } else {
    let _block$4;
    let _pipe = object_types;
    let _pipe$1 = $list.map(
      _pipe,
      (o) => { return generate_object_type(o, config); },
    );
    _block$4 = $string.join(_pipe$1, "\n\n");
    let object_code = _block$4;
    _block$3 = $list.append(parts$4, toList([object_code, ""]));
  }
  let parts$5 = _block$3;
  let input_types = get_input_types(schema);
  let _block$4;
  if (input_types instanceof $Empty) {
    _block$4 = parts$5;
  } else {
    let _block$5;
    let _pipe = input_types;
    let _pipe$1 = $list.map(
      _pipe,
      (i) => { return generate_input_type(i, config); },
    );
    _block$5 = $string.join(_pipe$1, "\n\n");
    let input_code = _block$5;
    _block$4 = $list.append(parts$5, toList([input_code, ""]));
  }
  let parts$6 = _block$4;
  let _block$5;
  let $2 = schema.query;
  if ($2 instanceof Some) {
    let query_type = $2[0];
    let query_code = generate_operations("Query", query_type, config);
    _block$5 = $list.append(parts$6, toList([query_code, ""]));
  } else {
    _block$5 = parts$6;
  }
  let parts$7 = _block$5;
  let _block$6;
  let $3 = schema.mutation;
  if ($3 instanceof Some) {
    let mutation_type = $3[0];
    let mutation_code = generate_operations("Mutation", mutation_type, config);
    _block$6 = $list.append(parts$7, toList([mutation_code, ""]));
  } else {
    _block$6 = parts$7;
  }
  let parts$8 = _block$6;
  let _pipe = parts$8;
  let _pipe$1 = $string.join(_pipe, "\n");
  return $string.trim(_pipe$1);
}

/**
 * Generate TypeScript code from a schema with default config
 */
export function generate(schema) {
  return generate_with_config(schema, default_config());
}
