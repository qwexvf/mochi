-module(mochi@codegen@typescript).
-compile([no_auto_import, nowarn_unused_vars, nowarn_unused_function, nowarn_nomatch, inline]).
-define(FILEPATH, "src/mochi/codegen/typescript.gleam").
-export([default_config/0, generate_with_config/2, generate/1]).
-export_type([config/0]).

-if(?OTP_RELEASE >= 27).
-define(MODULEDOC(Str), -moduledoc(Str)).
-define(DOC(Str), -doc(Str)).
-else.
-define(MODULEDOC(Str), -compile([])).
-define(DOC(Str), -compile([])).
-endif.

-type config() :: {config,
        boolean(),
        boolean(),
        boolean(),
        boolean(),
        gleam@option:option(binary())}.

-file("src/mochi/codegen/typescript.gleam", 38).
?DOC(" Default configuration\n").
-spec default_config() -> config().
default_config() ->
    {config,
        true,
        true,
        false,
        true,
        {some,
            <<"// Generated by mochi - Do not edit manually\n// https://github.com/qwexvf/mochi"/utf8>>}}.

-file("src/mochi/codegen/typescript.gleam", 144).
-spec generate_helpers() -> binary().
generate_helpers() ->
    <<"/** Represents nullable values */
export type Maybe<T> = T | null | undefined;

/** Represents a list that may contain null items */
export type MaybeList<T> = Maybe<Maybe<T>[]>;"/utf8>>.

-file("src/mochi/codegen/typescript.gleam", 152).
-spec generate_scalars(config()) -> binary().
generate_scalars(Config) ->
    Export_prefix = case erlang:element(2, Config) of
        true ->
            <<"export "/utf8>>;

        false ->
            <<""/utf8>>
    end,
    <<Export_prefix/binary,
        "type Scalars = {
  ID: string;
  String: string;
  Int: number;
  Float: number;
  Boolean: boolean;
  /** Custom scalar - extend as needed */
  DateTime: string;
  /** Custom scalar - extend as needed */
  JSON: Record<string, unknown>;
};"/utf8>>.

-file("src/mochi/codegen/typescript.gleam", 175).
-spec generate_enum(mochi@schema:enum_type(), config()) -> binary().
generate_enum(Enum_type, Config) ->
    Export_prefix = case erlang:element(2, Config) of
        true ->
            <<"export "/utf8>>;

        false ->
            <<""/utf8>>
    end,
    Values = begin
        _pipe = maps:to_list(erlang:element(4, Enum_type)),
        _pipe@1 = gleam@list:map(
            _pipe,
            fun(Kv) ->
                {Name, Value_def} = Kv,
                Comment = case erlang:element(3, Value_def) of
                    {some, Desc} ->
                        <<<<"  /** "/utf8, Desc/binary>>/binary, " */\n"/utf8>>;

                    none ->
                        <<""/utf8>>
                end,
                <<<<<<<<<<Comment/binary, "  "/utf8>>/binary, Name/binary>>/binary,
                            " = \""/utf8>>/binary,
                        Name/binary>>/binary,
                    "\","/utf8>>
            end
        ),
        gleam@string:join(_pipe@1, <<"\n"/utf8>>)
    end,
    Description = case erlang:element(3, Enum_type) of
        {some, Desc@1} ->
            <<<<"/** "/utf8, Desc@1/binary>>/binary, " */\n"/utf8>>;

        none ->
            <<""/utf8>>
    end,
    <<<<<<<<<<<<Description/binary, Export_prefix/binary>>/binary,
                        "enum "/utf8>>/binary,
                    (erlang:element(2, Enum_type))/binary>>/binary,
                " {\n"/utf8>>/binary,
            Values/binary>>/binary,
        "\n}"/utf8>>.

-file("src/mochi/codegen/typescript.gleam", 451).
-spec scalar_to_ts(binary()) -> binary().
scalar_to_ts(Name) ->
    case Name of
        <<"ID"/utf8>> ->
            <<"Scalars[\"ID\"]"/utf8>>;

        <<"String"/utf8>> ->
            <<"Scalars[\"String\"]"/utf8>>;

        <<"Int"/utf8>> ->
            <<"Scalars[\"Int\"]"/utf8>>;

        <<"Float"/utf8>> ->
            <<"Scalars[\"Float\"]"/utf8>>;

        <<"Boolean"/utf8>> ->
            <<"Scalars[\"Boolean\"]"/utf8>>;

        <<"DateTime"/utf8>> ->
            <<"Scalars[\"DateTime\"]"/utf8>>;

        <<"JSON"/utf8>> ->
            <<"Scalars[\"JSON\"]"/utf8>>;

        Custom ->
            Custom
    end.

-file("src/mochi/codegen/typescript.gleam", 465).
-spec is_nullable(mochi@schema:field_type()) -> boolean().
is_nullable(Field_type) ->
    case Field_type of
        {non_null, _} ->
            false;

        _ ->
            true
    end.

-file("src/mochi/codegen/typescript.gleam", 476).
-spec get_object_types(mochi@schema:schema()) -> list(mochi@schema:object_type()).
get_object_types(Schema) ->
    _pipe = maps:to_list(erlang:element(5, Schema)),
    gleam@list:filter_map(
        _pipe,
        fun(Kv) ->
            {_, Type_def} = Kv,
            case Type_def of
                {object_type_def, Obj} ->
                    {ok, Obj};

                _ ->
                    {error, nil}
            end
        end
    ).

-file("src/mochi/codegen/typescript.gleam", 487).
-spec get_enum_types(mochi@schema:schema()) -> list(mochi@schema:enum_type()).
get_enum_types(Schema) ->
    _pipe = maps:to_list(erlang:element(5, Schema)),
    gleam@list:filter_map(
        _pipe,
        fun(Kv) ->
            {_, Type_def} = Kv,
            case Type_def of
                {enum_type_def, Enum} ->
                    {ok, Enum};

                _ ->
                    {error, nil}
            end
        end
    ).

-file("src/mochi/codegen/typescript.gleam", 498).
-spec get_input_types(mochi@schema:schema()) -> list(mochi@schema:input_object_type()).
get_input_types(Schema) ->
    _pipe = maps:to_list(erlang:element(5, Schema)),
    gleam@list:filter_map(
        _pipe,
        fun(Kv) ->
            {_, Type_def} = Kv,
            case Type_def of
                {input_object_type_def, Input} ->
                    {ok, Input};

                _ ->
                    {error, nil}
            end
        end
    ).

-file("src/mochi/codegen/typescript.gleam", 513).
-spec capitalize(binary()) -> binary().
capitalize(Str) ->
    case gleam_stdlib:string_pop_grapheme(Str) of
        {ok, {First, Rest}} ->
            <<(string:uppercase(First))/binary, Rest/binary>>;

        {error, _} ->
            Str
    end.

-file("src/mochi/codegen/typescript.gleam", 443).
-spec field_type_to_ts_non_null(mochi@schema:field_type()) -> binary().
field_type_to_ts_non_null(Field_type) ->
    case Field_type of
        {non_null, Inner} ->
            field_type_to_ts_non_null(Inner);

        {list, Inner@1} ->
            <<(field_type_to_ts(Inner@1))/binary, "[]"/utf8>>;

        {named, Name} ->
            scalar_to_ts(Name)
    end.

-file("src/mochi/codegen/typescript.gleam", 435).
-spec field_type_to_ts(mochi@schema:field_type()) -> binary().
field_type_to_ts(Field_type) ->
    case Field_type of
        {non_null, Inner} ->
            field_type_to_ts_non_null(Inner);

        {list, Inner@1} ->
            <<<<"Maybe<"/utf8, (field_type_to_ts(Inner@1))/binary>>/binary,
                "[]>"/utf8>>;

        {named, Name} ->
            <<<<"Maybe<"/utf8, (scalar_to_ts(Name))/binary>>/binary, ">"/utf8>>
    end.

-file("src/mochi/codegen/typescript.gleam", 211).
-spec generate_object_type(mochi@schema:object_type(), config()) -> binary().
generate_object_type(Object_type, Config) ->
    Export_prefix = case erlang:element(2, Config) of
        true ->
            <<"export "/utf8>>;

        false ->
            <<""/utf8>>
    end,
    Keyword = case erlang:element(3, Config) of
        true ->
            <<"interface"/utf8>>;

        false ->
            <<"type"/utf8>>
    end,
    Readonly_prefix = case erlang:element(4, Config) of
        true ->
            <<"readonly "/utf8>>;

        false ->
            <<""/utf8>>
    end,
    Fields = begin
        _pipe = maps:to_list(erlang:element(4, Object_type)),
        _pipe@1 = gleam@list:map(
            _pipe,
            fun(Kv) ->
                {Name, Field_def} = Kv,
                Ts_type = field_type_to_ts(erlang:element(4, Field_def)),
                Optional = is_nullable(erlang:element(4, Field_def)),
                Optional_marker = case Optional of
                    true ->
                        <<"?"/utf8>>;

                    false ->
                        <<""/utf8>>
                end,
                Comment = case erlang:element(3, Field_def) of
                    {some, Desc} ->
                        <<<<"  /** "/utf8, Desc/binary>>/binary, " */\n"/utf8>>;

                    none ->
                        <<""/utf8>>
                end,
                <<<<<<<<<<<<<<Comment/binary, "  "/utf8>>/binary,
                                        Readonly_prefix/binary>>/binary,
                                    Name/binary>>/binary,
                                Optional_marker/binary>>/binary,
                            ": "/utf8>>/binary,
                        Ts_type/binary>>/binary,
                    ";"/utf8>>
            end
        ),
        gleam@string:join(_pipe@1, <<"\n"/utf8>>)
    end,
    Description = case erlang:element(3, Object_type) of
        {some, Desc@1} ->
            <<<<"/** "/utf8, Desc@1/binary>>/binary, " */\n"/utf8>>;

        none ->
            <<""/utf8>>
    end,
    Equals = case erlang:element(3, Config) of
        true ->
            <<" "/utf8>>;

        false ->
            <<" = "/utf8>>
    end,
    <<<<<<<<<<<<<<<<Description/binary, Export_prefix/binary>>/binary,
                                Keyword/binary>>/binary,
                            " "/utf8>>/binary,
                        (erlang:element(2, Object_type))/binary>>/binary,
                    Equals/binary>>/binary,
                "{\n"/utf8>>/binary,
            Fields/binary>>/binary,
        "\n}"/utf8>>.

-file("src/mochi/codegen/typescript.gleam", 279).
-spec generate_input_type(mochi@schema:input_object_type(), config()) -> binary().
generate_input_type(Input_type, Config) ->
    Export_prefix = case erlang:element(2, Config) of
        true ->
            <<"export "/utf8>>;

        false ->
            <<""/utf8>>
    end,
    Keyword = case erlang:element(3, Config) of
        true ->
            <<"interface"/utf8>>;

        false ->
            <<"type"/utf8>>
    end,
    Fields = begin
        _pipe = maps:to_list(erlang:element(4, Input_type)),
        _pipe@1 = gleam@list:map(
            _pipe,
            fun(Kv) ->
                {Name, Field_def} = Kv,
                Ts_type = field_type_to_ts(erlang:element(4, Field_def)),
                Optional = is_nullable(erlang:element(4, Field_def)),
                Optional_marker = case Optional of
                    true ->
                        <<"?"/utf8>>;

                    false ->
                        <<""/utf8>>
                end,
                Comment = case erlang:element(3, Field_def) of
                    {some, Desc} ->
                        <<<<"  /** "/utf8, Desc/binary>>/binary, " */\n"/utf8>>;

                    none ->
                        <<""/utf8>>
                end,
                <<<<<<<<<<<<Comment/binary, "  "/utf8>>/binary, Name/binary>>/binary,
                                Optional_marker/binary>>/binary,
                            ": "/utf8>>/binary,
                        Ts_type/binary>>/binary,
                    ";"/utf8>>
            end
        ),
        gleam@string:join(_pipe@1, <<"\n"/utf8>>)
    end,
    Description = case erlang:element(3, Input_type) of
        {some, Desc@1} ->
            <<<<"/** "/utf8, Desc@1/binary>>/binary, " */\n"/utf8>>;

        none ->
            <<""/utf8>>
    end,
    Equals = case erlang:element(3, Config) of
        true ->
            <<" "/utf8>>;

        false ->
            <<" = "/utf8>>
    end,
    <<<<<<<<<<<<<<<<Description/binary, Export_prefix/binary>>/binary,
                                Keyword/binary>>/binary,
                            " "/utf8>>/binary,
                        (erlang:element(2, Input_type))/binary>>/binary,
                    Equals/binary>>/binary,
                "{\n"/utf8>>/binary,
            Fields/binary>>/binary,
        "\n}"/utf8>>.

-file("src/mochi/codegen/typescript.gleam", 398).
-spec generate_args_type(binary(), mochi@schema:field_definition(), config()) -> binary().
generate_args_type(Type_name, Field_def, Config) ->
    Export_prefix = case erlang:element(2, Config) of
        true ->
            <<"export "/utf8>>;

        false ->
            <<""/utf8>>
    end,
    Fields = begin
        _pipe = maps:to_list(erlang:element(5, Field_def)),
        _pipe@1 = gleam@list:map(
            _pipe,
            fun(Kv) ->
                {Name, Arg_def} = Kv,
                Ts_type = field_type_to_ts(erlang:element(4, Arg_def)),
                Optional = is_nullable(erlang:element(4, Arg_def)),
                Optional_marker = case Optional of
                    true ->
                        <<"?"/utf8>>;

                    false ->
                        <<""/utf8>>
                end,
                Comment = case erlang:element(3, Arg_def) of
                    {some, Desc} ->
                        <<<<"  /** "/utf8, Desc/binary>>/binary, " */\n"/utf8>>;

                    none ->
                        <<""/utf8>>
                end,
                <<<<<<<<<<<<Comment/binary, "  "/utf8>>/binary, Name/binary>>/binary,
                                Optional_marker/binary>>/binary,
                            ": "/utf8>>/binary,
                        Ts_type/binary>>/binary,
                    ";"/utf8>>
            end
        ),
        gleam@string:join(_pipe@1, <<"\n"/utf8>>)
    end,
    <<<<<<<<<<Export_prefix/binary, "interface "/utf8>>/binary,
                    Type_name/binary>>/binary,
                " {\n"/utf8>>/binary,
            Fields/binary>>/binary,
        "\n}"/utf8>>.

-file("src/mochi/codegen/typescript.gleam", 335).
-spec generate_operations(binary(), mochi@schema:object_type(), config()) -> binary().
generate_operations(Name, Object_type, Config) ->
    Export_prefix = case erlang:element(2, Config) of
        true ->
            <<"export "/utf8>>;

        false ->
            <<""/utf8>>
    end,
    Arg_types = begin
        _pipe = maps:to_list(erlang:element(4, Object_type)),
        _pipe@1 = gleam@list:filter_map(
            _pipe,
            fun(Kv) ->
                {Field_name, Field_def} = Kv,
                case maps:size(erlang:element(5, Field_def)) > 0 of
                    true ->
                        Type_name = <<<<Name/binary,
                                (capitalize(Field_name))/binary>>/binary,
                            "Args"/utf8>>,
                        {ok, generate_args_type(Type_name, Field_def, Config)};

                    false ->
                        {error, nil}
                end
            end
        ),
        gleam@string:join(_pipe@1, <<"\n\n"/utf8>>)
    end,
    Fields = begin
        _pipe@2 = maps:to_list(erlang:element(4, Object_type)),
        _pipe@3 = gleam@list:map(
            _pipe@2,
            fun(Kv@1) ->
                {Field_name@1, Field_def@1} = Kv@1,
                Return_type = field_type_to_ts(erlang:element(4, Field_def@1)),
                Comment = case erlang:element(3, Field_def@1) of
                    {some, Desc} ->
                        <<<<"  /** "/utf8, Desc/binary>>/binary, " */\n"/utf8>>;

                    none ->
                        <<""/utf8>>
                end,
                case maps:size(erlang:element(5, Field_def@1)) > 0 of
                    true ->
                        Args_type = <<<<Name/binary,
                                (capitalize(Field_name@1))/binary>>/binary,
                            "Args"/utf8>>,
                        <<<<<<<<<<<<<<Comment/binary, "  "/utf8>>/binary,
                                                Field_name@1/binary>>/binary,
                                            "(args: "/utf8>>/binary,
                                        Args_type/binary>>/binary,
                                    "): "/utf8>>/binary,
                                Return_type/binary>>/binary,
                            ";"/utf8>>;

                    false ->
                        <<<<<<<<<<Comment/binary, "  "/utf8>>/binary,
                                        Field_name@1/binary>>/binary,
                                    ": "/utf8>>/binary,
                                Return_type/binary>>/binary,
                            ";"/utf8>>
                end
            end
        ),
        gleam@string:join(_pipe@3, <<"\n"/utf8>>)
    end,
    Ops_type = <<<<<<<<<<Export_prefix/binary, "interface "/utf8>>/binary,
                    Name/binary>>/binary,
                " {\n"/utf8>>/binary,
            Fields/binary>>/binary,
        "\n}"/utf8>>,
    case Arg_types of
        <<""/utf8>> ->
            Ops_type;

        _ ->
            <<<<Arg_types/binary, "\n\n"/utf8>>/binary, Ops_type/binary>>
    end.

-file("src/mochi/codegen/typescript.gleam", 60).
?DOC(" Generate TypeScript code with custom config\n").
-spec generate_with_config(mochi@schema:schema(), config()) -> binary().
generate_with_config(Schema, Config) ->
    Parts = [],
    Parts@1 = case erlang:element(6, Config) of
        {some, Header} ->
            [Header, <<""/utf8>>];

        none ->
            Parts
    end,
    Parts@2 = case erlang:element(5, Config) of
        true ->
            lists:append(Parts@1, [generate_helpers(), <<""/utf8>>]);

        false ->
            Parts@1
    end,
    Parts@3 = lists:append(Parts@2, [generate_scalars(Config), <<""/utf8>>]),
    Enum_types = get_enum_types(Schema),
    Parts@4 = case Enum_types of
        [] ->
            Parts@3;

        _ ->
            Enum_code = begin
                _pipe = Enum_types,
                _pipe@1 = gleam@list:map(
                    _pipe,
                    fun(E) -> generate_enum(E, Config) end
                ),
                gleam@string:join(_pipe@1, <<"\n\n"/utf8>>)
            end,
            lists:append(Parts@3, [Enum_code, <<""/utf8>>])
    end,
    Object_types = get_object_types(Schema),
    Parts@5 = case Object_types of
        [] ->
            Parts@4;

        _ ->
            Object_code = begin
                _pipe@2 = Object_types,
                _pipe@3 = gleam@list:map(
                    _pipe@2,
                    fun(O) -> generate_object_type(O, Config) end
                ),
                gleam@string:join(_pipe@3, <<"\n\n"/utf8>>)
            end,
            lists:append(Parts@4, [Object_code, <<""/utf8>>])
    end,
    Input_types = get_input_types(Schema),
    Parts@6 = case Input_types of
        [] ->
            Parts@5;

        _ ->
            Input_code = begin
                _pipe@4 = Input_types,
                _pipe@5 = gleam@list:map(
                    _pipe@4,
                    fun(I) -> generate_input_type(I, Config) end
                ),
                gleam@string:join(_pipe@5, <<"\n\n"/utf8>>)
            end,
            lists:append(Parts@5, [Input_code, <<""/utf8>>])
    end,
    Parts@7 = case erlang:element(2, Schema) of
        {some, Query_type} ->
            Query_code = generate_operations(
                <<"Query"/utf8>>,
                Query_type,
                Config
            ),
            lists:append(Parts@6, [Query_code, <<""/utf8>>]);

        none ->
            Parts@6
    end,
    Parts@8 = case erlang:element(3, Schema) of
        {some, Mutation_type} ->
            Mutation_code = generate_operations(
                <<"Mutation"/utf8>>,
                Mutation_type,
                Config
            ),
            lists:append(Parts@7, [Mutation_code, <<""/utf8>>]);

        none ->
            Parts@7
    end,
    _pipe@6 = Parts@8,
    _pipe@7 = gleam@string:join(_pipe@6, <<"\n"/utf8>>),
    gleam@string:trim(_pipe@7).

-file("src/mochi/codegen/typescript.gleam", 55).
?DOC(" Generate TypeScript code from a schema with default config\n").
-spec generate(mochi@schema:schema()) -> binary().
generate(Schema) ->
    generate_with_config(Schema, default_config()).
