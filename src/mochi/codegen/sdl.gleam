// mochi/codegen/sdl.gleam
// Generate GraphQL SDL (Schema Definition Language) from mochi schemas
//
// Usage:
//   let sdl = sdl.generate(schema)
//   // Write to file: schema.graphql

import gleam/dict
import gleam/list
import gleam/option.{type Option, None, Some}
import gleam/string
import mochi/schema.{
  type ArgumentDefinition, type DirectiveDefinition, type EnumType,
  type FieldDefinition, type FieldType, type InputObjectType, type InterfaceType,
  type ObjectType, type ScalarType, type Schema, type UnionType,
}

// ============================================================================
// Configuration
// ============================================================================

/// Configuration for SDL generation
pub type Config {
  Config(
    /// Include descriptions as comments
    include_descriptions: Bool,
    /// Include built-in scalar types (String, Int, etc.)
    include_builtin_scalars: Bool,
    /// Indent string (default: 2 spaces)
    indent: String,
    /// Header comment
    header: Option(String),
  )
}

/// Default configuration
pub fn default_config() -> Config {
  Config(
    include_descriptions: True,
    include_builtin_scalars: False,
    indent: "  ",
    header: Some("# Generated by mochi\n# https://github.com/qwexvf/mochi"),
  )
}

// ============================================================================
// Main Generation Functions
// ============================================================================

/// Generate SDL from a schema with default config
pub fn generate(schema: Schema) -> String {
  generate_with_config(schema, default_config())
}

/// Generate SDL with custom config
pub fn generate_with_config(schema: Schema, config: Config) -> String {
  let parts = []

  // Header
  let parts = case config.header {
    Some(header) -> [header, ""]
    None -> parts
  }

  // Scalars
  let scalar_types = get_scalar_types(schema, config)
  let parts = case scalar_types {
    [] -> parts
    _ -> {
      let scalars_sdl =
        scalar_types
        |> list.map(fn(s) { generate_scalar(s, config) })
        |> string.join("\n\n")
      list.append(parts, [scalars_sdl, ""])
    }
  }

  // Enums
  let enum_types = get_enum_types(schema)
  let parts = case enum_types {
    [] -> parts
    _ -> {
      let enums_sdl =
        enum_types
        |> list.map(fn(e) { generate_enum(e, config) })
        |> string.join("\n\n")
      list.append(parts, [enums_sdl, ""])
    }
  }

  // Interfaces
  let interface_types = get_interface_types(schema)
  let parts = case interface_types {
    [] -> parts
    _ -> {
      let interfaces_sdl =
        interface_types
        |> list.map(fn(i) { generate_interface(i, config) })
        |> string.join("\n\n")
      list.append(parts, [interfaces_sdl, ""])
    }
  }

  // Unions
  let union_types = get_union_types(schema)
  let parts = case union_types {
    [] -> parts
    _ -> {
      let unions_sdl =
        union_types
        |> list.map(fn(u) { generate_union(u, config) })
        |> string.join("\n\n")
      list.append(parts, [unions_sdl, ""])
    }
  }

  // Input types
  let input_types = get_input_types(schema)
  let parts = case input_types {
    [] -> parts
    _ -> {
      let inputs_sdl =
        input_types
        |> list.map(fn(i) { generate_input_type(i, config) })
        |> string.join("\n\n")
      list.append(parts, [inputs_sdl, ""])
    }
  }

  // Object types (excluding Query, Mutation, Subscription)
  let object_types = get_object_types(schema)
  let parts = case object_types {
    [] -> parts
    _ -> {
      let objects_sdl =
        object_types
        |> list.map(fn(o) { generate_object_type(o, config) })
        |> string.join("\n\n")
      list.append(parts, [objects_sdl, ""])
    }
  }

  // Query type
  let parts = case schema.query {
    Some(query_type) -> {
      let query_sdl = generate_object_type(query_type, config)
      list.append(parts, [query_sdl, ""])
    }
    None -> parts
  }

  // Mutation type
  let parts = case schema.mutation {
    Some(mutation_type) -> {
      let mutation_sdl = generate_object_type(mutation_type, config)
      list.append(parts, [mutation_sdl, ""])
    }
    None -> parts
  }

  // Subscription type
  let parts = case schema.subscription {
    Some(subscription_type) -> {
      let subscription_sdl = generate_object_type(subscription_type, config)
      list.append(parts, [subscription_sdl, ""])
    }
    None -> parts
  }

  // Schema definition (only if non-default root types)
  let parts = case needs_schema_definition(schema) {
    True -> list.append(parts, [generate_schema_definition(schema), ""])
    False -> parts
  }

  // Custom directive definitions
  let custom_directives = get_custom_directives(schema)
  let parts = case custom_directives {
    [] -> parts
    _ -> {
      let directives_sdl =
        custom_directives
        |> list.map(fn(d) { generate_directive(d, config) })
        |> string.join("\n\n")
      list.append(parts, [directives_sdl, ""])
    }
  }

  parts
  |> string.join("\n")
  |> string.trim
}

// ============================================================================
// Type Generators
// ============================================================================

fn generate_scalar(scalar: ScalarType, config: Config) -> String {
  let desc = generate_description(scalar.description, "", config)
  desc <> "scalar " <> scalar.name
}

fn generate_enum(enum_type: EnumType, config: Config) -> String {
  let desc = generate_description(enum_type.description, "", config)

  let values =
    dict.to_list(enum_type.values)
    |> list.map(fn(kv) {
      let #(name, value_def) = kv
      let value_desc =
        generate_description(value_def.description, config.indent, config)
      let deprecated = case value_def.is_deprecated {
        True ->
          case value_def.deprecation_reason {
            Some(reason) ->
              " @deprecated(reason: \"" <> escape_string(reason) <> "\")"
            None -> " @deprecated"
          }
        False -> ""
      }
      value_desc <> config.indent <> name <> deprecated
    })
    |> string.join("\n")

  desc <> "enum " <> enum_type.name <> " {\n" <> values <> "\n}"
}

fn generate_interface(interface: InterfaceType, config: Config) -> String {
  let desc = generate_description(interface.description, "", config)

  let fields =
    dict.to_list(interface.fields)
    |> list.map(fn(kv) {
      let #(_name, field_def) = kv
      generate_field(field_def, config)
    })
    |> string.join("\n")

  desc <> "interface " <> interface.name <> " {\n" <> fields <> "\n}"
}

fn generate_union(union: UnionType, config: Config) -> String {
  let desc = generate_description(union.description, "", config)

  let type_names =
    union.types
    |> list.map(fn(t) { t.name })
    |> string.join(" | ")

  desc <> "union " <> union.name <> " = " <> type_names
}

fn generate_input_type(input: InputObjectType, config: Config) -> String {
  let desc = generate_description(input.description, "", config)

  let fields =
    dict.to_list(input.fields)
    |> list.map(fn(kv) {
      let #(name, field_def) = kv
      let field_desc =
        generate_description(field_def.description, config.indent, config)
      field_desc
      <> config.indent
      <> name
      <> ": "
      <> field_type_to_sdl(field_def.field_type)
    })
    |> string.join("\n")

  desc <> "input " <> input.name <> " {\n" <> fields <> "\n}"
}

fn generate_object_type(object: ObjectType, config: Config) -> String {
  let desc = generate_description(object.description, "", config)

  let implements = case object.interfaces {
    [] -> ""
    interfaces -> {
      let names =
        interfaces
        |> list.map(fn(i) { i.name })
        |> string.join(" & ")
      " implements " <> names
    }
  }

  let fields =
    dict.to_list(object.fields)
    |> list.map(fn(kv) {
      let #(_name, field_def) = kv
      generate_field(field_def, config)
    })
    |> string.join("\n")

  desc <> "type " <> object.name <> implements <> " {\n" <> fields <> "\n}"
}

fn generate_field(field: FieldDefinition, config: Config) -> String {
  let desc = generate_description(field.description, config.indent, config)

  let args = case dict.size(field.arguments) > 0 {
    True -> "(" <> generate_arguments(field.arguments) <> ")"
    False -> ""
  }

  let deprecated = case field.is_deprecated {
    True ->
      case field.deprecation_reason {
        Some(reason) ->
          " @deprecated(reason: \"" <> escape_string(reason) <> "\")"
        None -> " @deprecated"
      }
    False -> ""
  }

  desc
  <> config.indent
  <> field.name
  <> args
  <> ": "
  <> field_type_to_sdl(field.field_type)
  <> deprecated
}

fn generate_arguments(
  arguments: dict.Dict(String, ArgumentDefinition),
) -> String {
  dict.to_list(arguments)
  |> list.map(fn(kv) {
    let #(name, arg_def) = kv
    let default = case arg_def.default_value {
      Some(_) -> " = <default>"
      // Note: proper default value serialization would need more work
      None -> ""
    }
    name <> ": " <> field_type_to_sdl(arg_def.arg_type) <> default
  })
  |> string.join(", ")
}

fn generate_schema_definition(schema: Schema) -> String {
  let fields = []

  let fields = case schema.query {
    Some(q) -> ["  query: " <> q.name, ..fields]
    None -> fields
  }

  let fields = case schema.mutation {
    Some(m) -> ["  mutation: " <> m.name, ..fields]
    None -> fields
  }

  let fields = case schema.subscription {
    Some(s) -> ["  subscription: " <> s.name, ..fields]
    None -> fields
  }

  "schema {\n" <> string.join(list.reverse(fields), "\n") <> "\n}"
}

// ============================================================================
// Helper Functions
// ============================================================================

fn generate_description(
  description: Option(String),
  indent: String,
  config: Config,
) -> String {
  case config.include_descriptions, description {
    True, Some(desc) -> {
      case string.contains(desc, "\n") {
        True ->
          indent <> "\"\"\"\n" <> indent <> desc <> "\n" <> indent <> "\"\"\"\n"
        False -> indent <> "\"" <> escape_string(desc) <> "\"\n"
      }
    }
    _, _ -> ""
  }
}

fn escape_string(s: String) -> String {
  s
  |> string.replace("\\", "\\\\")
  |> string.replace("\"", "\\\"")
  |> string.replace("\n", "\\n")
}

fn field_type_to_sdl(field_type: FieldType) -> String {
  case field_type {
    schema.NonNull(inner) -> field_type_to_sdl(inner) <> "!"
    schema.List(inner) -> "[" <> field_type_to_sdl(inner) <> "]"
    schema.Named(name) -> name
  }
}

fn needs_schema_definition(schema: Schema) -> Bool {
  // Only need explicit schema definition if root types have non-default names
  case schema.query, schema.mutation, schema.subscription {
    Some(q), _, _ if q.name != "Query" -> True
    _, Some(m), _ if m.name != "Mutation" -> True
    _, _, Some(s) if s.name != "Subscription" -> True
    _, _, _ -> False
  }
}

// ============================================================================
// Type Extraction Helpers
// ============================================================================

fn get_scalar_types(schema: Schema, config: Config) -> List(ScalarType) {
  let builtin = ["String", "Int", "Float", "Boolean", "ID"]

  dict.to_list(schema.types)
  |> list.filter_map(fn(kv) {
    let #(name, type_def) = kv
    case type_def {
      schema.ScalarTypeDef(scalar) -> {
        case config.include_builtin_scalars || !list.contains(builtin, name) {
          True -> Ok(scalar)
          False -> Error(Nil)
        }
      }
      _ -> Error(Nil)
    }
  })
}

fn get_enum_types(schema: Schema) -> List(EnumType) {
  dict.to_list(schema.types)
  |> list.filter_map(fn(kv) {
    let #(_name, type_def) = kv
    case type_def {
      schema.EnumTypeDef(enum) -> Ok(enum)
      _ -> Error(Nil)
    }
  })
}

fn get_interface_types(schema: Schema) -> List(InterfaceType) {
  dict.to_list(schema.types)
  |> list.filter_map(fn(kv) {
    let #(_name, type_def) = kv
    case type_def {
      schema.InterfaceTypeDef(interface) -> Ok(interface)
      _ -> Error(Nil)
    }
  })
}

fn get_union_types(schema: Schema) -> List(UnionType) {
  dict.to_list(schema.types)
  |> list.filter_map(fn(kv) {
    let #(_name, type_def) = kv
    case type_def {
      schema.UnionTypeDef(union) -> Ok(union)
      _ -> Error(Nil)
    }
  })
}

fn get_input_types(schema: Schema) -> List(InputObjectType) {
  dict.to_list(schema.types)
  |> list.filter_map(fn(kv) {
    let #(_name, type_def) = kv
    case type_def {
      schema.InputObjectTypeDef(input) -> Ok(input)
      _ -> Error(Nil)
    }
  })
}

fn get_object_types(schema: Schema) -> List(ObjectType) {
  dict.to_list(schema.types)
  |> list.filter_map(fn(kv) {
    let #(_name, type_def) = kv
    case type_def {
      schema.ObjectTypeDef(obj) -> Ok(obj)
      _ -> Error(Nil)
    }
  })
}

fn get_custom_directives(schema: Schema) -> List(DirectiveDefinition) {
  let builtin = ["skip", "include", "deprecated"]
  dict.to_list(schema.directives)
  |> list.filter_map(fn(kv) {
    let #(name, directive) = kv
    case list.contains(builtin, name) {
      True -> Error(Nil)
      False -> Ok(directive)
    }
  })
}

// ============================================================================
// Directive Generation
// ============================================================================

fn generate_directive(directive: DirectiveDefinition, config: Config) -> String {
  let desc = generate_description(directive.description, "", config)

  let args = case dict.size(directive.arguments) > 0 {
    True -> "(" <> generate_arguments(directive.arguments) <> ")"
    False -> ""
  }

  let repeatable = case directive.is_repeatable {
    True -> " repeatable"
    False -> ""
  }

  let locations =
    directive.locations
    |> list.map(schema.directive_location_to_string)
    |> string.join(" | ")

  desc
  <> "directive @"
  <> directive.name
  <> args
  <> repeatable
  <> " on "
  <> locations
}
