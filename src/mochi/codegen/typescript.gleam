// mochi/codegen/typescript.gleam
// Generate TypeScript type definitions from mochi GraphQL schemas
//
// Usage:
//   let ts_code = typescript.generate(schema)
//   // Write to file: types.generated.ts

import gleam/dict
import gleam/list
import gleam/option.{type Option, None, Some}
import gleam/string
import mochi/schema.{
  type EnumType, type FieldDefinition, type FieldType, type InputObjectType,
  type ObjectType, type Schema,
}

// ============================================================================
// Configuration
// ============================================================================

/// Configuration for TypeScript generation
pub type Config {
  Config(
    /// Add "export" before type declarations
    use_exports: Bool,
    /// Use "interface" instead of "type" for objects
    use_interfaces: Bool,
    /// Add readonly modifier to properties
    readonly_properties: Bool,
    /// Generate helper types (Maybe, Scalars, etc.)
    include_helpers: Bool,
    /// Header comment
    header: Option(String),
  )
}

/// Default configuration
pub fn default_config() -> Config {
  Config(
    use_exports: True,
    use_interfaces: True,
    readonly_properties: False,
    include_helpers: True,
    header: Some(
      "// Generated by mochi - Do not edit manually\n// https://github.com/qwexvf/mochi",
    ),
  )
}

// ============================================================================
// Main Generation Functions
// ============================================================================

/// Generate TypeScript code from a schema with default config
pub fn generate(schema: Schema) -> String {
  generate_with_config(schema, default_config())
}

/// Generate TypeScript code with custom config
pub fn generate_with_config(schema: Schema, config: Config) -> String {
  let parts = []

  // Header
  let parts = case config.header {
    Some(header) -> [header, ""]
    None -> parts
  }

  // Helper types
  let parts = case config.include_helpers {
    True -> list.append(parts, [generate_helpers(), ""])
    False -> parts
  }

  // Scalars
  let parts = list.append(parts, [generate_scalars(config), ""])

  // Enums
  let enum_types = get_enum_types(schema)
  let parts = case enum_types {
    [] -> parts
    _ -> {
      let enum_code =
        enum_types
        |> list.map(fn(e) { generate_enum(e, config) })
        |> string.join("\n\n")
      list.append(parts, [enum_code, ""])
    }
  }

  // Object types
  let object_types = get_object_types(schema)
  let parts = case object_types {
    [] -> parts
    _ -> {
      let object_code =
        object_types
        |> list.map(fn(o) { generate_object_type(o, config) })
        |> string.join("\n\n")
      list.append(parts, [object_code, ""])
    }
  }

  // Input types
  let input_types = get_input_types(schema)
  let parts = case input_types {
    [] -> parts
    _ -> {
      let input_code =
        input_types
        |> list.map(fn(i) { generate_input_type(i, config) })
        |> string.join("\n\n")
      list.append(parts, [input_code, ""])
    }
  }

  // Query type
  let parts = case schema.query {
    Some(query_type) -> {
      let query_code = generate_operations("Query", query_type, config)
      list.append(parts, [query_code, ""])
    }
    None -> parts
  }

  // Mutation type
  let parts = case schema.mutation {
    Some(mutation_type) -> {
      let mutation_code = generate_operations("Mutation", mutation_type, config)
      list.append(parts, [mutation_code, ""])
    }
    None -> parts
  }

  parts
  |> string.join("\n")
  |> string.trim
}

// ============================================================================
// Helper Types Generation
// ============================================================================

fn generate_helpers() -> String {
  "/** Represents nullable values */
export type Maybe<T> = T | null | undefined;

/** Represents a list that may contain null items */
export type MaybeList<T> = Maybe<Maybe<T>[]>;"
}

fn generate_scalars(config: Config) -> String {
  let export_prefix = case config.use_exports {
    True -> "export "
    False -> ""
  }

  export_prefix <> "type Scalars = {
  ID: string;
  String: string;
  Int: number;
  Float: number;
  Boolean: boolean;
  /** Custom scalar - extend as needed */
  DateTime: string;
  /** Custom scalar - extend as needed */
  JSON: Record<string, unknown>;
};"
}

// ============================================================================
// Enum Generation
// ============================================================================

fn generate_enum(enum_type: EnumType, config: Config) -> String {
  let export_prefix = case config.use_exports {
    True -> "export "
    False -> ""
  }

  let values =
    dict.to_list(enum_type.values)
    |> list.map(fn(kv) {
      let #(name, value_def) = kv
      let comment = case value_def.description {
        Some(desc) -> "  /** " <> desc <> " */\n"
        None -> ""
      }
      comment <> "  " <> name <> " = \"" <> name <> "\","
    })
    |> string.join("\n")

  let description = case enum_type.description {
    Some(desc) -> "/** " <> desc <> " */\n"
    None -> ""
  }

  description
  <> export_prefix
  <> "enum "
  <> enum_type.name
  <> " {\n"
  <> values
  <> "\n}"
}

// ============================================================================
// Object Type Generation
// ============================================================================

fn generate_object_type(object_type: ObjectType, config: Config) -> String {
  let export_prefix = case config.use_exports {
    True -> "export "
    False -> ""
  }

  let keyword = case config.use_interfaces {
    True -> "interface"
    False -> "type"
  }

  let readonly_prefix = case config.readonly_properties {
    True -> "readonly "
    False -> ""
  }

  let fields =
    dict.to_list(object_type.fields)
    |> list.map(fn(kv) {
      let #(name, field_def) = kv
      let ts_type = field_type_to_ts(field_def.field_type)
      let optional = is_nullable(field_def.field_type)
      let optional_marker = case optional {
        True -> "?"
        False -> ""
      }

      let comment = case field_def.description {
        Some(desc) -> "  /** " <> desc <> " */\n"
        None -> ""
      }

      comment
      <> "  "
      <> readonly_prefix
      <> name
      <> optional_marker
      <> ": "
      <> ts_type
      <> ";"
    })
    |> string.join("\n")

  let description = case object_type.description {
    Some(desc) -> "/** " <> desc <> " */\n"
    None -> ""
  }

  let equals = case config.use_interfaces {
    True -> " "
    False -> " = "
  }

  description
  <> export_prefix
  <> keyword
  <> " "
  <> object_type.name
  <> equals
  <> "{\n"
  <> fields
  <> "\n}"
}

// ============================================================================
// Input Type Generation
// ============================================================================

fn generate_input_type(input_type: InputObjectType, config: Config) -> String {
  let export_prefix = case config.use_exports {
    True -> "export "
    False -> ""
  }

  let keyword = case config.use_interfaces {
    True -> "interface"
    False -> "type"
  }

  let fields =
    dict.to_list(input_type.fields)
    |> list.map(fn(kv) {
      let #(name, field_def) = kv
      let ts_type = field_type_to_ts(field_def.field_type)
      let optional = is_nullable(field_def.field_type)
      let optional_marker = case optional {
        True -> "?"
        False -> ""
      }

      let comment = case field_def.description {
        Some(desc) -> "  /** " <> desc <> " */\n"
        None -> ""
      }

      comment <> "  " <> name <> optional_marker <> ": " <> ts_type <> ";"
    })
    |> string.join("\n")

  let description = case input_type.description {
    Some(desc) -> "/** " <> desc <> " */\n"
    None -> ""
  }

  let equals = case config.use_interfaces {
    True -> " "
    False -> " = "
  }

  description
  <> export_prefix
  <> keyword
  <> " "
  <> input_type.name
  <> equals
  <> "{\n"
  <> fields
  <> "\n}"
}

// ============================================================================
// Operations Generation (Query/Mutation)
// ============================================================================

fn generate_operations(
  name: String,
  object_type: ObjectType,
  config: Config,
) -> String {
  let export_prefix = case config.use_exports {
    True -> "export "
    False -> ""
  }

  // Generate argument types for each field
  let arg_types =
    dict.to_list(object_type.fields)
    |> list.filter_map(fn(kv) {
      let #(field_name, field_def) = kv
      case dict.size(field_def.arguments) > 0 {
        True -> {
          let type_name = name <> capitalize(field_name) <> "Args"
          Ok(generate_args_type(type_name, field_def, config))
        }
        False -> Error(Nil)
      }
    })
    |> string.join("\n\n")

  // Generate the main operations type
  let fields =
    dict.to_list(object_type.fields)
    |> list.map(fn(kv) {
      let #(field_name, field_def) = kv
      let return_type = field_type_to_ts(field_def.field_type)

      let comment = case field_def.description {
        Some(desc) -> "  /** " <> desc <> " */\n"
        None -> ""
      }

      case dict.size(field_def.arguments) > 0 {
        True -> {
          let args_type = name <> capitalize(field_name) <> "Args"
          comment
          <> "  "
          <> field_name
          <> "(args: "
          <> args_type
          <> "): "
          <> return_type
          <> ";"
        }
        False -> comment <> "  " <> field_name <> ": " <> return_type <> ";"
      }
    })
    |> string.join("\n")

  let ops_type =
    export_prefix <> "interface " <> name <> " {\n" <> fields <> "\n}"

  case arg_types {
    "" -> ops_type
    _ -> arg_types <> "\n\n" <> ops_type
  }
}

fn generate_args_type(
  type_name: String,
  field_def: FieldDefinition,
  config: Config,
) -> String {
  let export_prefix = case config.use_exports {
    True -> "export "
    False -> ""
  }

  let fields =
    dict.to_list(field_def.arguments)
    |> list.map(fn(kv) {
      let #(name, arg_def) = kv
      let ts_type = field_type_to_ts(arg_def.arg_type)
      let optional = is_nullable(arg_def.arg_type)
      let optional_marker = case optional {
        True -> "?"
        False -> ""
      }

      let comment = case arg_def.description {
        Some(desc) -> "  /** " <> desc <> " */\n"
        None -> ""
      }

      comment <> "  " <> name <> optional_marker <> ": " <> ts_type <> ";"
    })
    |> string.join("\n")

  export_prefix <> "interface " <> type_name <> " {\n" <> fields <> "\n}"
}

// ============================================================================
// Type Conversion Helpers
// ============================================================================

fn field_type_to_ts(field_type: FieldType) -> String {
  case field_type {
    schema.NonNull(inner) -> field_type_to_ts_non_null(inner)
    schema.List(inner) -> "Maybe<" <> field_type_to_ts(inner) <> "[]>"
    schema.Named(name) -> "Maybe<" <> scalar_to_ts(name) <> ">"
  }
}

fn field_type_to_ts_non_null(field_type: FieldType) -> String {
  case field_type {
    schema.NonNull(inner) -> field_type_to_ts_non_null(inner)
    schema.List(inner) -> field_type_to_ts(inner) <> "[]"
    schema.Named(name) -> scalar_to_ts(name)
  }
}

fn scalar_to_ts(name: String) -> String {
  case name {
    "ID" -> "Scalars[\"ID\"]"
    "String" -> "Scalars[\"String\"]"
    "Int" -> "Scalars[\"Int\"]"
    "Float" -> "Scalars[\"Float\"]"
    "Boolean" -> "Scalars[\"Boolean\"]"
    "DateTime" -> "Scalars[\"DateTime\"]"
    "JSON" -> "Scalars[\"JSON\"]"
    // Custom type - use as-is
    custom -> custom
  }
}

fn is_nullable(field_type: FieldType) -> Bool {
  case field_type {
    schema.NonNull(_) -> False
    _ -> True
  }
}

// ============================================================================
// Schema Helpers
// ============================================================================

fn get_object_types(schema: Schema) -> List(ObjectType) {
  dict.to_list(schema.types)
  |> list.filter_map(fn(kv) {
    let #(_name, type_def) = kv
    case type_def {
      schema.ObjectTypeDef(obj) -> Ok(obj)
      _ -> Error(Nil)
    }
  })
}

fn get_enum_types(schema: Schema) -> List(EnumType) {
  dict.to_list(schema.types)
  |> list.filter_map(fn(kv) {
    let #(_name, type_def) = kv
    case type_def {
      schema.EnumTypeDef(enum) -> Ok(enum)
      _ -> Error(Nil)
    }
  })
}

fn get_input_types(schema: Schema) -> List(InputObjectType) {
  dict.to_list(schema.types)
  |> list.filter_map(fn(kv) {
    let #(_name, type_def) = kv
    case type_def {
      schema.InputObjectTypeDef(input) -> Ok(input)
      _ -> Error(Nil)
    }
  })
}

// ============================================================================
// String Helpers
// ============================================================================

fn capitalize(str: String) -> String {
  case string.pop_grapheme(str) {
    Ok(#(first, rest)) -> string.uppercase(first) <> rest
    Error(_) -> str
  }
}
