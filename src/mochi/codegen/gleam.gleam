// Gleam code generation from GraphQL schema
// Generates Gleam types and resolver stubs from SDL

import gleam/list
import gleam/option.{Some}
import gleam/string
import mochi/sdl_ast.{
  type EnumTypeDef, type EnumValueDef, type FieldDef, type InputFieldDef,
  type InputObjectTypeDef, type InterfaceTypeDef, type ObjectTypeDef,
  type SDLDocument, type SDLType, type ScalarTypeDef, type TypeDef,
  type UnionTypeDef,
}

/// Configuration for Gleam code generation
pub type GleamGenConfig {
  GleamGenConfig(
    /// Module name for generated types
    types_module: String,
    /// Module name for generated resolvers
    resolvers_module: String,
    /// Whether to generate resolver stubs
    generate_resolvers: Bool,
    /// Whether to add doc comments
    generate_docs: Bool,
  )
}

/// Default configuration
pub fn default_config() -> GleamGenConfig {
  GleamGenConfig(
    types_module: "schema_types",
    resolvers_module: "resolvers",
    generate_resolvers: True,
    generate_docs: True,
  )
}

/// Generate Gleam types from SDL document
pub fn generate_types(doc: SDLDocument, config: GleamGenConfig) -> String {
  let header = "// Generated by mochi - DO NOT EDIT\n\n"

  let imports = "import gleam/option.{type Option}\n\n"

  let types =
    doc.definitions
    |> list.filter_map(fn(def) {
      case def {
        sdl_ast.TypeDefinition(type_def) ->
          Ok(generate_type_def(type_def, config))
        _ -> Error(Nil)
      }
    })
    |> string.join("\n\n")

  header <> imports <> types
}

/// Generate resolver stubs from SDL document
pub fn generate_resolvers(doc: SDLDocument, config: GleamGenConfig) -> String {
  let header =
    "// Generated by mochi - DO NOT EDIT\n// TODO: Implement resolver functions\n\n"

  let imports =
    "import gleam/dynamic.{type Dynamic}\n"
    <> "import gleam/result\n"
    <> "import mochi/schema.{type ExecutionContext}\n"
    <> "import "
    <> config.types_module
    <> "\n\n"

  let resolvers =
    doc.definitions
    |> list.filter_map(fn(def) {
      case def {
        sdl_ast.TypeDefinition(sdl_ast.ObjectTypeDefinition(obj)) ->
          Ok(generate_object_resolvers(obj, config))
        _ -> Error(Nil)
      }
    })
    |> list.filter(fn(s) { s != "" })
    |> string.join("\n\n")

  header <> imports <> resolvers
}

// Type definition generators

fn generate_type_def(type_def: TypeDef, config: GleamGenConfig) -> String {
  case type_def {
    sdl_ast.ObjectTypeDefinition(obj) -> generate_object_type(obj, config)
    sdl_ast.InterfaceTypeDefinition(iface) ->
      generate_interface_type(iface, config)
    sdl_ast.UnionTypeDefinition(union) -> generate_union_type(union, config)
    sdl_ast.EnumTypeDefinition(enum) -> generate_enum_type(enum, config)
    sdl_ast.InputObjectTypeDefinition(input) ->
      generate_input_type(input, config)
    sdl_ast.ScalarTypeDefinition(scalar) -> generate_scalar_type(scalar, config)
  }
}

fn generate_object_type(obj: ObjectTypeDef, config: GleamGenConfig) -> String {
  let doc = case config.generate_docs, obj.description {
    True, Some(desc) -> "/// " <> desc <> "\n"
    _, _ -> ""
  }

  let fields =
    obj.fields
    |> list.map(fn(field) { generate_record_field(field) })
    |> string.join(",\n    ")

  doc
  <> "pub type "
  <> obj.name
  <> " {\n  "
  <> obj.name
  <> "(\n    "
  <> fields
  <> ",\n  )\n}"
}

fn generate_record_field(field: FieldDef) -> String {
  let field_name = to_snake_case(field.name)
  let field_type = sdl_type_to_gleam(field.field_type)
  field_name <> ": " <> field_type
}

fn generate_interface_type(
  iface: InterfaceTypeDef,
  config: GleamGenConfig,
) -> String {
  let doc = case config.generate_docs, iface.description {
    True, Some(desc) -> "/// " <> desc <> "\n"
    _, _ -> ""
  }

  // Generate as a type alias to Dynamic for flexibility
  doc <> "pub type " <> iface.name <> " =\n  Dynamic"
}

fn generate_union_type(union: UnionTypeDef, config: GleamGenConfig) -> String {
  let doc = case config.generate_docs, union.description {
    True, Some(desc) -> "/// " <> desc <> "\n"
    _, _ -> ""
  }

  let variants =
    union.member_types
    |> list.map(fn(member) {
      "  " <> union.name <> member <> "(" <> member <> ")"
    })
    |> string.join("\n")

  doc <> "pub type " <> union.name <> " {\n" <> variants <> "\n}"
}

fn generate_enum_type(enum: EnumTypeDef, config: GleamGenConfig) -> String {
  let doc = case config.generate_docs, enum.description {
    True, Some(desc) -> "/// " <> desc <> "\n"
    _, _ -> ""
  }

  let values =
    enum.values
    |> list.map(fn(v) { generate_enum_value(v, enum.name, config) })
    |> string.join("\n")

  doc <> "pub type " <> enum.name <> " {\n" <> values <> "\n}"
}

fn generate_enum_value(
  value: EnumValueDef,
  _enum_name: String,
  config: GleamGenConfig,
) -> String {
  let doc = case config.generate_docs, value.description {
    True, Some(desc) -> "  /// " <> desc <> "\n"
    _, _ -> ""
  }
  doc <> "  " <> to_pascal_case(value.name)
}

fn generate_input_type(
  input: InputObjectTypeDef,
  config: GleamGenConfig,
) -> String {
  let doc = case config.generate_docs, input.description {
    True, Some(desc) -> "/// " <> desc <> "\n"
    _, _ -> ""
  }

  let fields =
    input.fields
    |> list.map(fn(field) { generate_input_field(field) })
    |> string.join(",\n    ")

  doc
  <> "pub type "
  <> input.name
  <> " {\n  "
  <> input.name
  <> "(\n    "
  <> fields
  <> ",\n  )\n}"
}

fn generate_input_field(field: InputFieldDef) -> String {
  let field_name = to_snake_case(field.name)
  let field_type = sdl_type_to_gleam(field.field_type)
  field_name <> ": " <> field_type
}

fn generate_scalar_type(scalar: ScalarTypeDef, config: GleamGenConfig) -> String {
  let doc = case config.generate_docs, scalar.description {
    True, Some(desc) -> "/// " <> desc <> "\n"
    _, _ -> ""
  }

  // Generate as type alias
  doc <> "pub type " <> scalar.name <> " =\n  String"
}

// Resolver generators

fn generate_object_resolvers(
  obj: ObjectTypeDef,
  config: GleamGenConfig,
) -> String {
  // Skip Query, Mutation, Subscription - they need custom resolvers
  case obj.name {
    "Query" | "Mutation" | "Subscription" ->
      generate_root_resolvers(obj, config)
    _ -> ""
  }
}

fn generate_root_resolvers(obj: ObjectTypeDef, config: GleamGenConfig) -> String {
  let header = "// " <> obj.name <> " resolvers\n"

  let resolvers =
    obj.fields
    |> list.map(fn(field) { generate_field_resolver(obj.name, field, config) })
    |> string.join("\n\n")

  header <> resolvers
}

fn generate_field_resolver(
  _parent_name: String,
  field: FieldDef,
  config: GleamGenConfig,
) -> String {
  let fn_name = "resolve_" <> to_snake_case(field.name)
  let return_type = sdl_type_to_gleam(field.field_type)

  let args_params = case field.arguments {
    [] -> ""
    args ->
      ", "
      <> {
        args
        |> list.map(fn(arg) {
          to_snake_case(arg.name) <> ": " <> sdl_type_to_gleam(arg.arg_type)
        })
        |> string.join(", ")
      }
  }

  let doc = case config.generate_docs, field.description {
    True, Some(desc) -> "/// " <> desc <> "\n"
    _, _ -> ""
  }

  doc
  <> "pub fn "
  <> fn_name
  <> "(ctx: ExecutionContext"
  <> args_params
  <> ") -> Result("
  <> return_type
  <> ", String) {\n"
  <> "  // TODO: Implement resolver\n"
  <> "  Error(\"Not implemented: "
  <> fn_name
  <> "\")\n"
  <> "}"
}

// Type conversion helpers

fn sdl_type_to_gleam(sdl_type: SDLType) -> String {
  case sdl_type {
    sdl_ast.NamedType(name) -> scalar_to_gleam(name)
    sdl_ast.NonNullType(inner) -> sdl_type_to_gleam(inner)
    sdl_ast.ListType(inner) -> "List(" <> sdl_type_to_gleam(inner) <> ")"
  }
}

fn scalar_to_gleam(name: String) -> String {
  case name {
    "String" -> "String"
    "Int" -> "Int"
    "Float" -> "Float"
    "Boolean" -> "Bool"
    "ID" -> "String"
    other -> other
  }
}

// String utilities

fn to_snake_case(input: String) -> String {
  input
  |> string.to_graphemes
  |> list.index_map(fn(char, idx) {
    case is_uppercase(char), idx {
      True, 0 -> string.lowercase(char)
      True, _ -> "_" <> string.lowercase(char)
      False, _ -> char
    }
  })
  |> string.join("")
}

fn to_pascal_case(input: String) -> String {
  input
  |> string.split("_")
  |> list.map(fn(part) {
    case string.pop_grapheme(part) {
      Ok(#(first, rest)) -> string.uppercase(first) <> string.lowercase(rest)
      Error(_) -> part
    }
  })
  |> string.join("")
}

fn is_uppercase(char: String) -> Bool {
  char == string.uppercase(char) && char != string.lowercase(char)
}
